<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gempyor.outcomes &#8212; gempyor  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for gempyor.outcomes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="kn">import</span> <span class="nn">tqdm.contrib.concurrent</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">Timer</span><span class="p">,</span> <span class="n">_nslots_random_seeds</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">read_df</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">NPI</span><span class="p">,</span> <span class="n">model_info</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="run_parallel_outcomes">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.run_parallel_outcomes">[docs]</a>
<span class="k">def</span> <span class="nf">run_parallel_outcomes</span><span class="p">(</span>
    <span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sim_id2write</span><span class="p">,</span> <span class="n">nslots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run outcome simulations in parallel.</span>

<span class="sd">    Args:</span>
<span class="sd">        modinf: ModelInfo object.</span>
<span class="sd">        sim_id2write: Simulation ID to write.</span>
<span class="sd">        nslots: Number of slots to run in parallel.</span>
<span class="sd">        n_jobs: Number of jobs to run in parallel.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Always returns 1.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Successive calls to this function will produce different samples for random</span>
<span class="sd">        parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
    <span class="n">sim_id2writes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sim_id2write</span><span class="p">,</span> <span class="n">sim_id2write</span> <span class="o">+</span> <span class="n">modinf</span><span class="o">.</span><span class="n">nslots</span><span class="p">)</span>
    <span class="n">random_seeds</span> <span class="o">=</span> <span class="n">_nslots_random_seeds</span><span class="p">(</span><span class="n">nslots</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">modinf</span><span class="o">.</span><span class="n">nslots</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">):</span>  <span class="c1"># run single process for debugging/profiling purposes</span>
        <span class="k">for</span> <span class="n">sim_offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslots</span><span class="p">):</span>
            <span class="n">_onerun_delayframe_outcomes_with_random_seed</span><span class="p">(</span>
                <span class="n">random_seeds</span><span class="p">[</span><span class="n">sim_offset</span><span class="p">],</span>
                <span class="n">sim_id2writes</span><span class="p">[</span><span class="n">sim_offset</span><span class="p">],</span>
                <span class="n">modinf</span><span class="o">=</span><span class="n">modinf</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tqdm</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="n">process_map</span><span class="p">(</span>
            <span class="n">_onerun_delayframe_outcomes_with_random_seed</span><span class="p">,</span>
            <span class="n">random_seeds</span><span class="p">,</span>
            <span class="n">sim_id2writes</span><span class="p">,</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">modinf</span><span class="p">),</span>
            <span class="n">max_workers</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;&gt;&gt; </span><span class="si">{</span><span class="n">nslots</span><span class="si">}</span><span class="s2"> outcomes simulations completed &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="build_outcome_modifiers">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.build_outcome_modifiers">[docs]</a>
<span class="k">def</span> <span class="nf">build_outcome_modifiers</span><span class="p">(</span>
    <span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span>
    <span class="n">load_ID</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">sim_id2load</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">config</span><span class="p">,</span>
    <span class="n">bypass_DF</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">bypass_FN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s2">&quot;Outcomes.Modifiers&quot;</span><span class="p">):</span>
        <span class="n">loaded_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">bypass_DF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loaded_df</span> <span class="o">=</span> <span class="n">bypass_DF</span>
        <span class="k">elif</span> <span class="n">bypass_FN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loaded_df</span> <span class="o">=</span> <span class="n">read_df</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="n">bypass_FN</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">load_ID</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">loaded_df</span> <span class="o">=</span> <span class="n">modinf</span><span class="o">.</span><span class="n">read_simID</span><span class="p">(</span><span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;hnpi&quot;</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id2load</span><span class="p">)</span>

        <span class="n">npi</span> <span class="o">=</span> <span class="n">NPI</span><span class="o">.</span><span class="n">NPIBase</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">npi_config</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">npi_config_outcomes</span><span class="p">,</span>
            <span class="n">modinf_ti</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">ti</span><span class="p">,</span>
            <span class="n">modinf_tf</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">tf</span><span class="p">,</span>
            <span class="n">modifiers_library</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">outcome_modifiers_library</span><span class="p">,</span>
            <span class="n">subpops</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
            <span class="n">loaded_df</span><span class="o">=</span><span class="n">loaded_df</span><span class="p">,</span>
            <span class="c1"># TODO: support other operation than product</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">npi</span></div>



<div class="viewcode-block" id="onerun_delayframe_outcomes">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.onerun_delayframe_outcomes">[docs]</a>
<span class="k">def</span> <span class="nf">onerun_delayframe_outcomes</span><span class="p">(</span>
    <span class="n">sim_id2write</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span>
    <span class="n">load_ID</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sim_id2load</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s2">&quot;buildOutcome.structure&quot;</span><span class="p">):</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">read_parameters_from_config</span><span class="p">(</span><span class="n">modinf</span><span class="p">)</span>

    <span class="n">npi_outcomes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">npi_config_outcomes</span><span class="p">:</span>
        <span class="n">npi_outcomes</span> <span class="o">=</span> <span class="n">build_outcome_modifiers</span><span class="p">(</span>
            <span class="n">modinf</span><span class="o">=</span><span class="n">modinf</span><span class="p">,</span> <span class="n">load_ID</span><span class="o">=</span><span class="n">load_ID</span><span class="p">,</span> <span class="n">sim_id2load</span><span class="o">=</span><span class="n">sim_id2load</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span>
        <span class="p">)</span>

    <span class="n">loaded_values</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">load_ID</span><span class="p">:</span>
        <span class="n">loaded_values</span> <span class="o">=</span> <span class="n">modinf</span><span class="o">.</span><span class="n">read_simID</span><span class="p">(</span><span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;hpar&quot;</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id2load</span><span class="p">)</span>

    <span class="c1"># Compute outcomes</span>
    <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s2">&quot;onerun_delayframe_outcomes.compute&quot;</span><span class="p">):</span>
        <span class="n">outcomes_df</span><span class="p">,</span> <span class="n">hpar</span> <span class="o">=</span> <span class="n">compute_all_multioutcomes</span><span class="p">(</span>
            <span class="n">modinf</span><span class="o">=</span><span class="n">modinf</span><span class="p">,</span>
            <span class="n">sim_id2write</span><span class="o">=</span><span class="n">sim_id2write</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
            <span class="n">loaded_values</span><span class="o">=</span><span class="n">loaded_values</span><span class="p">,</span>
            <span class="n">npi</span><span class="o">=</span><span class="n">npi_outcomes</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s2">&quot;onerun_delayframe_outcomes.postprocess&quot;</span><span class="p">):</span>
        <span class="n">postprocess_and_write</span><span class="p">(</span>
            <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id2write</span><span class="p">,</span>
            <span class="n">modinf</span><span class="o">=</span><span class="n">modinf</span><span class="p">,</span>
            <span class="n">outcomes_df</span><span class="o">=</span><span class="n">outcomes_df</span><span class="p">,</span>
            <span class="n">hpar</span><span class="o">=</span><span class="n">hpar</span><span class="p">,</span>
            <span class="n">npi</span><span class="o">=</span><span class="n">npi_outcomes</span><span class="p">,</span>
        <span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_onerun_delayframe_outcomes_with_random_seed</span><span class="p">(</span>
    <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sim_id2write</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span>
    <span class="n">load_ID</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sim_id2load</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to run `onerun_delayframe_outcomes` with a random seed.</span>

<span class="sd">    Args:</span>
<span class="sd">        random_seed: Random seed to use for the run.</span>
<span class="sd">        sim_id2write: Simulation ID to write.</span>
<span class="sd">        modinf: ModelInfo object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>

<span class="sd">    See Also:</span>
<span class="sd">        `onerun_delayframe_outcomes`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">onerun_delayframe_outcomes</span><span class="p">(</span>
        <span class="n">sim_id2write</span><span class="p">,</span> <span class="n">modinf</span><span class="p">,</span> <span class="n">load_ID</span><span class="o">=</span><span class="n">load_ID</span><span class="p">,</span> <span class="n">sim_id2load</span><span class="o">=</span><span class="n">sim_id2load</span>
    <span class="p">)</span>


<div class="viewcode-block" id="read_parameters_from_config">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.read_parameters_from_config">[docs]</a>
<span class="k">def</span> <span class="nf">read_parameters_from_config</span><span class="p">(</span><span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s2">&quot;Outcome.structure&quot;</span><span class="p">):</span>
        <span class="c1"># Prepare the probability table:</span>
        <span class="c1"># Either mean of probabilities given or from the file... This speeds up a bit the process.</span>
        <span class="c1"># However needs an ordered dict, here we&#39;re abusing a bit the spec.</span>
        <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">outcomes_config</span> <span class="o">=</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span><span class="p">[</span><span class="s2">&quot;outcomes&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span><span class="p">[</span><span class="s2">&quot;param_from_file&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span><span class="p">[</span><span class="s2">&quot;param_from_file&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
                <span class="c1"># Load the actual csv file</span>
                <span class="n">branching_file</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">modinf</span><span class="o">.</span><span class="n">path_prefix</span>
                    <span class="o">/</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span><span class="p">[</span><span class="s2">&quot;param_subpop_file&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_str</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">branching_data</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">parquet</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">branching_file</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;relative_probability&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">branching_data</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;There is no `relative_probability` quantity in &#39;</span><span class="si">{</span><span class="n">branching_file</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                    <span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Loaded subpops in loaded relative probablity file:&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">branching_data</span><span class="o">.</span><span class="n">subpop</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span>
                    <span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">branching_data</span> <span class="o">=</span> <span class="n">branching_data</span><span class="p">[</span>
                    <span class="n">branching_data</span><span class="p">[</span><span class="s2">&quot;subpop&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Intersect with seir simulation: &quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">branching_data</span><span class="o">.</span><span class="n">subpop</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span>
                    <span class="s2">&quot;kept&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branching_data</span><span class="o">.</span><span class="n">subpop</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;SEIR input files do not have subpops that match those in outcome probability file &#39;</span><span class="si">{</span><span class="n">branching_file</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                    <span class="p">)</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">new_comp</span> <span class="ow">in</span> <span class="n">outcomes_config</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># Read the config for this compartement</span>
                <span class="n">src_name</span> <span class="o">=</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_name</span>
                <span class="k">elif</span> <span class="p">(</span><span class="s2">&quot;incidence&quot;</span> <span class="ow">in</span> <span class="n">src_name</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;prevalence&quot;</span> <span class="ow">in</span> <span class="n">src_name</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">src_name</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected a `str` or `dict` containing `incidence` or `prevalence`. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Instead given &#39;</span><span class="si">{</span><span class="n">src_name</span><span class="si">}</span><span class="s2">&#39; for outcome &#39;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                    <span class="p">)</span>

                <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span>
                    <span class="s2">&quot;probability&quot;</span>
                <span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;probability&quot;</span><span class="p">][</span><span class="s2">&quot;modifier_parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;probability::npi_param_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;probability&quot;</span><span class="p">][</span><span class="s2">&quot;modifier_parameter&quot;</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">as_str</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;probability of outcome </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2"> is affected by intervention &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;named </span><span class="si">{</span><span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s1">&#39;probability::npi_param_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;instead of </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::probability&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span>
                        <span class="s2">&quot;probability::npi_param_name&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::probability&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">][</span>
                        <span class="s2">&quot;value&quot;</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">][</span><span class="s2">&quot;modifier_parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay::npi_param_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">][</span><span class="s2">&quot;modifier_parameter&quot;</span><span class="p">]</span>
                            <span class="o">.</span><span class="n">as_str</span><span class="p">()</span>
                            <span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                        <span class="p">)</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;delay of outcome </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2"> is affected by intervention &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;named </span><span class="si">{</span><span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s1">&#39;delay::npi_param_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;instead of </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::delay&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span>
                            <span class="s2">&quot;delay::npi_param_name&quot;</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::delay&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No delay for outcome </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">, using a 0 delay&quot;</span><span class="p">)</span>
                    <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">][</span>
                        <span class="s2">&quot;value&quot;</span>
                    <span class="p">]</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span>
                        <span class="s2">&quot;delay::npi_param_name&quot;</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::delay&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span>
                        <span class="s2">&quot;duration&quot;</span>
                    <span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">][</span><span class="s2">&quot;modifier_parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration::npi_param_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">][</span><span class="s2">&quot;modifier_parameter&quot;</span><span class="p">]</span>
                            <span class="o">.</span><span class="n">as_str</span><span class="p">()</span>
                            <span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                        <span class="p">)</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;duration of outcome </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2"> is affected by intervention &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;named </span><span class="si">{</span><span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s1">&#39;duration::npi_param_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;instead of </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::duration&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span>
                            <span class="s2">&quot;duration::npi_param_name&quot;</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">::duration&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;outcome_prevalence_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="c1">#    outcomes_config[new_comp][&quot;duration&quot;][&quot;name&quot;].as_str() + subclass</span>
                            <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_str</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># parameters[class_name][&quot;outcome_prevalence_name&quot;] = new_comp + &quot;_curr&quot; + subclass</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;outcome_prevalence_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_comp</span> <span class="o">+</span> <span class="s2">&quot;_curr&quot;</span>
                <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span><span class="p">[</span><span class="s2">&quot;param_from_file&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">outcomes_config</span><span class="p">[</span><span class="s2">&quot;param_from_file&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
                        <span class="n">rel_probability</span> <span class="o">=</span> <span class="n">branching_data</span><span class="p">[</span>
                            <span class="p">(</span><span class="n">branching_data</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_comp</span><span class="p">)</span>
                            <span class="o">&amp;</span> <span class="p">(</span><span class="n">branching_data</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;relative_probability&quot;</span><span class="p">)</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_probability</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Using &#39;param_from_file&#39; for relative probability in outcome </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="c1"># Sort it in case the relative probablity file is mispecified</span>
                            <span class="n">rel_probability</span><span class="o">.</span><span class="n">subpop</span> <span class="o">=</span> <span class="n">rel_probability</span><span class="o">.</span><span class="n">subpop</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                                <span class="s2">&quot;category&quot;</span>
                            <span class="p">)</span>
                            <span class="n">rel_probability</span><span class="o">.</span><span class="n">subpop</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">rel_probability</span><span class="o">.</span><span class="n">subpop</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span>
                                    <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">rel_probability</span> <span class="o">=</span> <span class="n">rel_probability</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;subpop&quot;</span><span class="p">])</span>
                            <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;rel_probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_probability</span><span class="p">[</span>
                                <span class="s2">&quot;value&quot;</span>
                            <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;*NOT* Using &#39;param_from_file&#39; for relative probability in outcome  </span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

            <span class="k">elif</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;sum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;sum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outcomes_config</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;sum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No `source` or `sum` specified for comp &#39;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">parameters</span></div>



<div class="viewcode-block" id="postprocess_and_write">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.postprocess_and_write">[docs]</a>
<span class="k">def</span> <span class="nf">postprocess_and_write</span><span class="p">(</span>
    <span class="n">sim_id</span><span class="p">,</span> <span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span> <span class="n">outcomes_df</span><span class="p">,</span> <span class="n">hpar</span><span class="p">,</span> <span class="n">npi</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
        <span class="n">modinf</span><span class="o">.</span><span class="n">write_simID</span><span class="p">(</span><span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;hosp&quot;</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">outcomes_df</span><span class="p">)</span>
        <span class="n">modinf</span><span class="o">.</span><span class="n">write_simID</span><span class="p">(</span><span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;hpar&quot;</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">hpar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">npi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hnpi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;subpop&quot;</span><span class="p">,</span>
                <span class="s2">&quot;modifier_name&quot;</span><span class="p">,</span>
                <span class="s2">&quot;start_date&quot;</span><span class="p">,</span>
                <span class="s2">&quot;end_date&quot;</span><span class="p">,</span>
                <span class="s2">&quot;parameter&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hnpi</span> <span class="o">=</span> <span class="n">npi</span><span class="o">.</span><span class="n">getReductionDF</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">write</span><span class="p">:</span>
        <span class="n">modinf</span><span class="o">.</span><span class="n">write_simID</span><span class="p">(</span><span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;hnpi&quot;</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">hnpi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outcomes_df</span><span class="p">,</span> <span class="n">hpar</span><span class="p">,</span> <span class="n">hnpi</span></div>



<div class="viewcode-block" id="dataframe_from_array">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.dataframe_from_array">[docs]</a>
<span class="k">def</span> <span class="nf">dataframe_from_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">subpops</span><span class="p">,</span> <span class="n">dates</span><span class="p">,</span> <span class="n">comp_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce a dataframe in long form from a numpy matrix of</span>
<span class="sd">    dimensions: dates * subpops. This dataframe are merged together</span>
<span class="sd">    to produce the final output</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">subpops</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dates</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;date&quot;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="n">comp_name</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;subpop&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="read_seir_sim">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.read_seir_sim">[docs]</a>
<span class="k">def</span> <span class="nf">read_seir_sim</span><span class="p">(</span><span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span> <span class="n">sim_id</span><span class="p">):</span>
    <span class="n">seir_df</span> <span class="o">=</span> <span class="n">modinf</span><span class="o">.</span><span class="n">read_simID</span><span class="p">(</span><span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;seir&quot;</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">seir_df</span></div>



<div class="viewcode-block" id="compute_all_multioutcomes">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.compute_all_multioutcomes">[docs]</a>
<span class="k">def</span> <span class="nf">compute_all_multioutcomes</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">modinf</span><span class="p">:</span> <span class="n">model_info</span><span class="o">.</span><span class="n">ModelInfo</span><span class="p">,</span>
    <span class="n">sim_id2write</span><span class="p">,</span>
    <span class="n">parameters</span><span class="p">,</span>
    <span class="n">loaded_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">npi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">bypass_seir_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bypass_seir_xr</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute delay frame based on temporally varying input. We load the seir sim corresponding to sim_id to write&quot;&quot;&quot;</span>
    <span class="n">hpar_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">ti</span><span class="p">,</span> <span class="n">modinf</span><span class="o">.</span><span class="n">tf</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>

    <span class="n">outcomes</span> <span class="o">=</span> <span class="n">dataframe_from_array</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
        <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
        <span class="n">dates</span><span class="p">,</span>
        <span class="s2">&quot;zeros&quot;</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;zeros&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bypass_seir_df</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bypass_seir_xr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seir_sim</span> <span class="o">=</span> <span class="n">read_seir_sim</span><span class="p">(</span><span class="n">modinf</span><span class="p">,</span> <span class="n">sim_id</span><span class="o">=</span><span class="n">sim_id2write</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bypass_seir_xr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seir_sim</span> <span class="o">=</span> <span class="n">bypass_seir_xr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seir_sim</span> <span class="o">=</span> <span class="n">bypass_seir_df</span>

    <span class="n">parameters_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">new_comp</span> <span class="ow">in</span> <span class="n">parameters_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;source&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]:</span>
            <span class="c1"># Read the config for this compartment: if a source is specified, we</span>
            <span class="c1"># 1. compute incidence from binomial draw</span>
            <span class="c1"># 2. compute duration if needed</span>
            <span class="n">source_name</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seir_sim</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">source_array</span> <span class="o">=</span> <span class="n">filter_seir_df</span><span class="p">(</span>
                        <span class="n">diffI</span><span class="o">=</span><span class="n">seir_sim</span><span class="p">,</span>
                        <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span>
                        <span class="n">subpops</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="n">source_name</span><span class="p">,</span>
                        <span class="n">outcome_name</span><span class="o">=</span><span class="n">new_comp</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seir_sim</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                    <span class="n">source_array</span> <span class="o">=</span> <span class="n">filter_seir_xr</span><span class="p">(</span>
                        <span class="n">diffI</span><span class="o">=</span><span class="n">seir_sim</span><span class="p">,</span>
                        <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span>
                        <span class="n">subpops</span><span class="o">=</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="n">source_name</span><span class="p">,</span>
                        <span class="n">outcome_name</span><span class="o">=</span><span class="n">new_comp</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unknown type provided for seir simulation, received &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">seir_sim</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># we don&#39;t keep source in this cases</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># already defined outcomes</span>
                <span class="k">if</span> <span class="n">source_name</span> <span class="ow">in</span> <span class="n">all_data</span><span class="p">:</span>
                    <span class="n">source_array</span> <span class="o">=</span> <span class="n">all_data</span><span class="p">[</span><span class="n">source_name</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">source_name</span> <span class="ow">in</span> <span class="n">parameters_keys</span><span class="p">:</span>
                    <span class="n">parameters_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comp</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Issue with outcome &#39;</span><span class="si">{</span><span class="n">new_comp</span><span class="si">}</span><span class="s2">&#39;; the specified source &#39;</span><span class="si">{</span><span class="n">source_name</span><span class="si">}</span><span class="s2">&#39; is neither a dictionnary (for seir outcome) nor an existing pre-identified outcome.&quot;</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">loaded_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">new_comp</span> <span class="ow">in</span> <span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="p">):</span>
                <span class="c1">## This may be unnecessary</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">loaded_values</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;probability&quot;</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_comp</span><span class="p">)</span>
                <span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="n">loaded_values</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;delay&quot;</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_comp</span><span class="p">)</span>
                <span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># One draw for all subpops</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_random_distribution</span><span class="p">()(),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;rel_probability&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]:</span>
                    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">probabilities</span> <span class="o">*</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;rel_probability&quot;</span><span class="p">]</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_random_distribution</span><span class="p">()(),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">probabilities</span><span class="p">[</span><span class="n">probabilities</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">probabilities</span><span class="p">[</span><span class="n">probabilities</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">probabilities</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># duplicate in time</span>
            <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">delays</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># duplicate in time</span>
            <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Write hpar before NPI</span>
            <span class="n">subpop_names_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">)</span>
            <span class="n">hpar</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;subpop&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
                    <span class="s2">&quot;quantity&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">subpop_names_len</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">])</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">subpop_names_len</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;delay&quot;</span><span class="p">]),</span>
                    <span class="s2">&quot;outcome&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subpop_names_len</span> <span class="o">*</span> <span class="p">[</span><span class="n">new_comp</span><span class="p">],</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">probabilities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">subpop_names_len</span><span class="p">),</span>
                            <span class="n">delays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">subpop_names_len</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">hpar_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hpar</span><span class="p">)</span>
            <span class="c1"># Now tackle NPI</span>
            <span class="k">if</span> <span class="n">npi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="n">NPI</span><span class="o">.</span><span class="n">reduce_parameter</span><span class="p">(</span>
                    <span class="n">parameter</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
                    <span class="n">modification</span><span class="o">=</span><span class="n">npi</span><span class="o">.</span><span class="n">getReduction</span><span class="p">(</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;delay::npi_param_name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="p">),</span>
                <span class="p">)</span>

                <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">NPI</span><span class="o">.</span><span class="n">reduce_parameter</span><span class="p">(</span>
                    <span class="n">parameter</span><span class="o">=</span><span class="n">probabilities</span><span class="p">,</span>
                    <span class="n">modification</span><span class="o">=</span><span class="n">npi</span><span class="o">.</span><span class="n">getReduction</span><span class="p">(</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;probability::npi_param_name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="p">),</span>
                <span class="p">)</span>

            <span class="c1"># Create new compartment incidence:</span>
            <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">source_array</span><span class="p">)</span>
            <span class="c1"># Draw with from source compartment</span>
            <span class="k">if</span> <span class="n">modinf</span><span class="o">.</span><span class="n">get_engine</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;stochastic&quot;</span><span class="p">:</span>
                <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span>
                    <span class="n">source_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">probabilities</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_array</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">probabilities</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">source_array</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Shift to account for the delay</span>
            <span class="c1">## stoch_delay_flag is whether to use stochastic delays or not</span>
            <span class="n">stoch_delay_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">multishift</span><span class="p">(</span>
                <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">],</span> <span class="n">delays</span><span class="p">,</span> <span class="n">stoch_delay_flag</span><span class="o">=</span><span class="n">stoch_delay_flag</span>
            <span class="p">)</span>
            <span class="c1"># Produce a dataframe an merge it</span>
            <span class="n">df_p</span> <span class="o">=</span> <span class="n">dataframe_from_array</span><span class="p">(</span>
                <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">],</span> <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span> <span class="n">dates</span><span class="p">,</span> <span class="n">new_comp</span>
            <span class="p">)</span>
            <span class="n">outcomes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">df_p</span><span class="p">)</span>

            <span class="c1"># Make duration</span>
            <span class="k">if</span> <span class="s2">&quot;duration&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">loaded_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">new_comp</span> <span class="ow">in</span> <span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="p">):</span>
                    <span class="n">durations</span> <span class="o">=</span> <span class="n">loaded_values</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;quantity&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;duration&quot;</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">loaded_values</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_comp</span><span class="p">)</span>
                    <span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_random_distribution</span><span class="p">()(),</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">durations</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># duplicate in time</span>
                <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">hpar</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;subpop&quot;</span><span class="p">:</span> <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
                        <span class="s2">&quot;quantity&quot;</span><span class="p">:</span> <span class="n">subpop_names_len</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;duration&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;outcome&quot;</span><span class="p">:</span> <span class="n">subpop_names_len</span> <span class="o">*</span> <span class="p">[</span><span class="n">new_comp</span><span class="p">],</span>
                        <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">durations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">subpop_names_len</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="n">hpar_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hpar</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">npi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># import matplotlib.pyplot as plt</span>
                    <span class="c1"># plt.imshow(durations)</span>
                    <span class="c1"># plt.title(durations.mean())</span>
                    <span class="c1"># plt.colorbar()</span>
                    <span class="c1"># plt.savefig(&#39;Dbef&#39;+new_comp + &#39;-&#39; + source)</span>
                    <span class="c1"># plt.close()</span>
                    <span class="c1"># print(f&quot;{new_comp}-duration&quot;.lower(), npi.getReduction(f&quot;{new_comp}-duration&quot;.lower()))</span>
                    <span class="n">durations</span> <span class="o">=</span> <span class="n">NPI</span><span class="o">.</span><span class="n">reduce_parameter</span><span class="p">(</span>
                        <span class="n">parameter</span><span class="o">=</span><span class="n">durations</span><span class="p">,</span>
                        <span class="n">modification</span><span class="o">=</span><span class="n">npi</span><span class="o">.</span><span class="n">getReduction</span><span class="p">(</span>
                            <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;duration::npi_param_name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                        <span class="p">),</span>
                    <span class="p">)</span>  <span class="c1"># npi.getReduction(f&quot;{new_comp}::duration&quot;.lower()))</span>
                    <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="c1"># plt.imshow(durations)</span>
                    <span class="c1"># plt.title(durations.mean())</span>
                    <span class="c1"># plt.colorbar()</span>
                    <span class="c1"># plt.savefig(&#39;Daft&#39;+new_comp + &#39;-&#39; + source)</span>
                    <span class="c1"># plt.close()</span>

                <span class="n">all_data</span><span class="p">[</span><span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;outcome_prevalence_name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
                    <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">multishift</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">durations</span><span class="p">,</span>
                    <span class="n">stoch_delay_flag</span><span class="o">=</span><span class="n">stoch_delay_flag</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">df_p</span> <span class="o">=</span> <span class="n">dataframe_from_array</span><span class="p">(</span>
                    <span class="n">all_data</span><span class="p">[</span><span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;outcome_prevalence_name&quot;</span><span class="p">]],</span>
                    <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span>
                    <span class="n">dates</span><span class="p">,</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;outcome_prevalence_name&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">outcomes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">df_p</span><span class="p">)</span>

        <span class="k">elif</span> <span class="s2">&quot;sum&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]:</span>
            <span class="n">sum_outcome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">)),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">all_data</span><span class="p">[</span><span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;sum&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Sum all concerned compartment.</span>
            <span class="k">for</span> <span class="n">cmp</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">new_comp</span><span class="p">][</span><span class="s2">&quot;sum&quot;</span><span class="p">]:</span>
                <span class="n">sum_outcome</span> <span class="o">+=</span> <span class="n">all_data</span><span class="p">[</span><span class="n">cmp</span><span class="p">]</span>
            <span class="n">all_data</span><span class="p">[</span><span class="n">new_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_outcome</span>
            <span class="n">df_p</span> <span class="o">=</span> <span class="n">dataframe_from_array</span><span class="p">(</span>
                <span class="n">sum_outcome</span><span class="p">,</span> <span class="n">modinf</span><span class="o">.</span><span class="n">subpop_struct</span><span class="o">.</span><span class="n">subpop_names</span><span class="p">,</span> <span class="n">dates</span><span class="p">,</span> <span class="n">new_comp</span>
            <span class="p">)</span>
            <span class="n">outcomes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">df_p</span><span class="p">)</span>
    <span class="c1"># Concat our hpar dataframes</span>
    <span class="n">hpar</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">hpar_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hpar_list</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;subpop&quot;</span><span class="p">,</span> <span class="s2">&quot;quantity&quot;</span><span class="p">,</span> <span class="s2">&quot;outcome&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">outcomes</span><span class="p">,</span> <span class="n">hpar</span></div>



<div class="viewcode-block" id="filter_seir_df">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.filter_seir_df">[docs]</a>
<span class="k">def</span> <span class="nf">filter_seir_df</span><span class="p">(</span><span class="n">diffI</span><span class="p">,</span> <span class="n">dates</span><span class="p">,</span> <span class="n">subpops</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">outcome_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;incidence&quot;</span><span class="p">]:</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="s2">&quot;incidence&quot;</span>
    <span class="k">elif</span> <span class="nb">list</span><span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;prevalence&quot;</span><span class="p">]:</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="s2">&quot;prevalence&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot discern the source of outcome &#39;</span><span class="si">{</span><span class="n">outcome_name</span><span class="si">}</span><span class="s2">&#39;; it is not a previously defined outcome and there is no `incidence` or `prevalence`.&quot;</span>
        <span class="p">)</span>

    <span class="n">diffI</span> <span class="o">=</span> <span class="n">diffI</span><span class="p">[</span><span class="n">diffI</span><span class="p">[</span><span class="s2">&quot;mc_value_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">vtype</span><span class="p">]</span>
    <span class="c1"># diffI.drop([&quot;mc_value_type&quot;], inplace=True, axis=1)</span>
    <span class="n">filters</span> <span class="o">=</span> <span class="n">filters</span><span class="p">[</span><span class="n">vtype</span><span class="p">]</span>

    <span class="n">incidI_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpops</span><span class="p">)))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">diffI</span>
    <span class="k">for</span> <span class="n">mc_type</span><span class="p">,</span> <span class="n">mc_value</span> <span class="ow">in</span> <span class="n">filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mc_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mc_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">mc_value</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;mc_</span><span class="si">{</span><span class="n">mc_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mc_value</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">mcn</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;mc_name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;mc_name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">mcn</span><span class="p">]</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">new_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s2">&quot;mc_&quot;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># new_df = new_df.drop(&quot;date&quot;, axis=1)</span>
        <span class="n">incidI_arr</span> <span class="o">=</span> <span class="n">incidI_arr</span> <span class="o">+</span> <span class="n">new_df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">incidI_arr</span></div>



<div class="viewcode-block" id="filter_seir_xr">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.filter_seir_xr">[docs]</a>
<span class="k">def</span> <span class="nf">filter_seir_xr</span><span class="p">(</span><span class="n">diffI</span><span class="p">,</span> <span class="n">dates</span><span class="p">,</span> <span class="n">subpops</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">outcome_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Determine the variable type (prevalence or incidence)</span>
    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;incidence&quot;</span><span class="p">]:</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="s2">&quot;incidence&quot;</span>
    <span class="k">elif</span> <span class="nb">list</span><span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;prevalence&quot;</span><span class="p">]:</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="s2">&quot;prevalence&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot discern the source of outcome &#39;</span><span class="si">{</span><span class="n">outcome_name</span><span class="si">}</span><span class="s2">&#39;; it is not a previously defined outcome and there is no `incidence` or `prevalence`.&quot;</span>
        <span class="p">)</span>
    <span class="c1"># Filter the data</span>
    <span class="n">filters</span> <span class="o">=</span> <span class="n">filters</span><span class="p">[</span><span class="n">vtype</span><span class="p">]</span>

    <span class="c1"># Initialize the array to store filtered incidence values</span>
    <span class="c1"># Initialize the array to store filtered incidence values</span>
    <span class="n">incidI_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpops</span><span class="p">)))</span>

    <span class="n">diffI_filtered</span> <span class="o">=</span> <span class="n">diffI</span>
    <span class="k">for</span> <span class="n">mc_type</span><span class="p">,</span> <span class="n">mc_value</span> <span class="ow">in</span> <span class="n">filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Check if mc_value is a string or list of strings</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mc_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mc_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">mc_value</span><span class="p">]</span>
        <span class="c1"># Filter data along the specified mc_type dimension</span>
        <span class="n">diffI_filtered</span> <span class="o">=</span> <span class="n">diffI_filtered</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">diffI_filtered</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;mc_</span><span class="si">{</span><span class="n">mc_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mc_value</span><span class="p">),</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="c1"># Sum along the compartment dimension</span>
    <span class="n">incidI_arr</span> <span class="o">+=</span> <span class="n">diffI_filtered</span><span class="p">[</span><span class="n">vtype</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;compartment&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">incidI_arr</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span></div>



<div class="viewcode-block" id="shift">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.shift">[docs]</a>
<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quite fast shift implementation, along the first axis,</span>
<span class="sd">    which is date. num is an integer not negative nor zero</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="c1"># if num &gt; 0:</span>
        <span class="n">result</span><span class="p">[:</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">result</span><span class="p">[</span><span class="n">num</span><span class="p">:]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="n">num</span><span class="p">]</span>
    <span class="c1"># elif num &lt; 0:</span>
    <span class="c1">#    result[num:] = fill_value</span>
    <span class="c1">#    result[:num] = arr[-num:]</span>
    <span class="c1"># else:</span>
    <span class="c1">#    result[:] = arr</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="multishiftee">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.multishiftee">[docs]</a>
<span class="k">def</span> <span class="nf">multishiftee</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">stoch_delay_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shift along first (0) axis&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stoch_delay_flag</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;`stoch_delay_flag` not supported yet.&quot;</span><span class="p">)</span>
        <span class="c1"># for i, row in reversed(enumerate(np.rows(arr))):</span>
        <span class="c1">#    for j,elem in reversed(enumerate(row)):</span>
        <span class="c1">## This function takes in :</span>
        <span class="c1">##  - elem (int &gt; 0)</span>
        <span class="c1">##  - delay (single average delay)</span>
        <span class="c1">## and outputs</span>
        <span class="c1">##  - vector of fixed size where the k element stores # of people who are delayed by k</span>
        <span class="c1"># percentages = np.random.multinomial(el&lt;fixed based on delays[i][j]&gt;)</span>
        <span class="c1">#        cases = diff(round(cumsum(percentages)*elem))</span>
        <span class="c1">#        for k,case in enumerate(cases):</span>
        <span class="c1">#            results[i+k][j] = cases[k]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">elem</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="multishift">
<a class="viewcode-back" href="../../api/gempyor.html#gempyor.outcomes.multishift">[docs]</a>
<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">multishift</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">stoch_delay_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shift along first (0) axis&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stoch_delay_flag</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;`stoch_delay_flag` not supported yet.&quot;</span><span class="p">)</span>
        <span class="c1"># for i, row in reversed(enumerate(np.rows(arr))):</span>
        <span class="c1">#    for j,elem in reversed(enumerate(row)):</span>
        <span class="c1">## This function takes in :</span>
        <span class="c1">##  - elem (int &gt; 0)</span>
        <span class="c1">##  - delay (single average delay)</span>
        <span class="c1">## and outputs</span>
        <span class="c1">##  - vector of fixed size where the k element stores # of people who are delayed by k</span>
        <span class="c1"># percentages = np.random.multinomial(el&lt;fixed based on delays[i][j]&gt;)</span>
        <span class="c1">#        cases = diff(round(cumsum(percentages)*elem))</span>
        <span class="c1">#        for k,case in enumerate(cases):</span>
        <span class="c1">#            results[i+k][j] = cases[k]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>  <span class="c1"># numba nopython does not allow iterating over 2D array</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">gempyor</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/gempyor.html">gempyor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/gempyor.html">gempyor package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, ACCIDDA.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>